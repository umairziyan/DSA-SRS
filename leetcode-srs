#!/usr/bin/env python3
"""
LeetCode Spaced Repetition System (SRS) CLI Tool

A simple CLI to track LeetCode problems using spaced repetition
with the FSRS-6 (Free Spaced Repetition Scheduler) algorithm.

FSRS is a modern spaced repetition algorithm that models memory with:
- Stability (S): Time in days for retrievability to drop to 90%
- Difficulty (D): Inherent complexity of the material [1-10]
- Retrievability (R): Current probability of recall [0-1]

See: https://github.com/open-spaced-repetition/fsrs4anki
"""

import json
import os
import re
import subprocess
import sys
import uuid
from datetime import datetime, timedelta
from pathlib import Path

# Store data in the same folder as the script
SCRIPT_DIR = Path(__file__).resolve().parent
DATA_FILE = SCRIPT_DIR / "leetcode-srs-data.json"

# Git sync settings
GIT_SYNC_ENABLED = True  # Set to False to disable auto-sync

# Daily limits
MAX_PRIORITY_PER_DAY = 5  # Number of problems to highlight as priority
MIN_ADDS_PER_DAY = 3      # Minimum new problems to add daily

# FSRS-6 Algorithm Parameters (21 total)
# See: https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm
FSRS_PARAMS = [
    0.212,    # w0:  S0(1) - initial stability for Again
    1.2931,   # w1:  S0(2) - initial stability for Hard
    2.3065,   # w2:  S0(3) - initial stability for Good
    8.2956,   # w3:  S0(4) - initial stability for Easy
    6.4133,   # w4:  D0 base - initial difficulty calculation
    0.8334,   # w5:  D0 scale - initial difficulty calculation
    3.0194,   # w6:  Difficulty delta factor
    0.001,    # w7:  Mean reversion weight
    1.8722,   # w8:  Stability recall factor
    0.1666,   # w9:  Stability recall exponent
    0.796,    # w10: Stability recall retrievability factor
    1.4835,   # w11: Stability forget factor
    0.0614,   # w12: Stability forget difficulty exponent
    0.2629,   # w13: Stability forget stability exponent
    1.6483,   # w14: Stability forget retrievability factor
    0.6014,   # w15: Hard penalty
    1.8729,   # w16: Easy bonus
    0.5425,   # w17: Same-day stability factor
    0.0912,   # w18: Same-day rating offset
    0.0658,   # w19: Same-day stability exponent
    0.1542    # w20: Reserved for future use
]

# FSRS Constants
FSRS_FACTOR = 19 / 81  # F constant for retrievability formula
FSRS_DECAY = -0.5      # C constant for retrievability formula
DESIRED_RETENTION = 0.9  # Target recall probability (90%)

# Rating constants (FSRS uses 1-4, not 0-3)
RATING_AGAIN = 1
RATING_HARD = 2
RATING_GOOD = 3
RATING_EASY = 4

# Colors for terminal output
class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RESET = "\033[0m"


# ============================================================================
# FSRS-6 Algorithm Functions
# ============================================================================

import math

def clamp(value, min_val, max_val):
    """Clamp value to range [min_val, max_val]."""
    return max(min_val, min(max_val, value))


def calculate_retrievability(elapsed_days, stability):
    """
    Calculate retrievability (probability of recall).

    Formula: R(t, S) = (1 + F * (t/S))^C
    Where: F = 19/81, C = -0.5

    Returns: Retrievability R in range [0, 1]
    """
    if stability <= 0:
        return 0.0
    return math.pow(1 + FSRS_FACTOR * (elapsed_days / stability), FSRS_DECAY)


def calculate_interval(stability, desired_retention=DESIRED_RETENTION):
    """
    Calculate optimal review interval from stability.

    Formula: I = S * ln(desired_retention) / ln(0.9)
    Note: When desired_retention = 0.9, interval equals stability.

    Returns: Interval in whole days (minimum 1)
    """
    if stability <= 0:
        return 1
    interval = stability * math.log(desired_retention) / math.log(0.9)
    return max(1, round(interval))


def get_initial_stability(rating):
    """
    Get initial stability for first review.

    Formula: S0(G) = w[G-1] for G in {1, 2, 3, 4}
    """
    if rating < 1 or rating > 4:
        rating = 3  # Default to Good
    return FSRS_PARAMS[rating - 1]


def get_initial_difficulty(rating):
    """
    Calculate initial difficulty.

    Formula: D0(G) = w4 - e^(w5 * (G-1)) + 1
    Clamped to range [1, 10]
    """
    w4, w5 = FSRS_PARAMS[4], FSRS_PARAMS[5]
    d0 = w4 - math.exp(w5 * (rating - 1)) + 1
    return clamp(d0, 1.0, 10.0)


def update_difficulty(difficulty, rating):
    """
    Update difficulty after a review.

    Step 1: delta_D = -w6 * (G - 3)
    Step 2: D' = D + delta_D * (10 - D) / 9
    Step 3: Mean reversion: D'' = w7 * D0(4) + (1 - w7) * D'

    Returns: Updated difficulty D'' in range [1, 10]
    """
    w6, w7 = FSRS_PARAMS[6], FSRS_PARAMS[7]

    # Step 1: Calculate delta
    delta_d = -w6 * (rating - 3)

    # Step 2: Apply delta with scaling factor
    d_prime = difficulty + delta_d * (10 - difficulty) / 9

    # Step 3: Mean reversion toward D0(4)
    d0_4 = get_initial_difficulty(4)
    d_new = w7 * d0_4 + (1 - w7) * d_prime

    return clamp(d_new, 1.0, 10.0)


def update_stability_success(difficulty, stability, retrievability, rating):
    """
    Update stability after successful recall (rating >= 2).

    Formula:
    S'_r(D,S,R,G) = S * (e^w8 * (11-D) * S^(-w9) * (e^(w10*(1-R))-1)
                        * hard_penalty * easy_bonus + 1)
    """
    w8, w9, w10 = FSRS_PARAMS[8], FSRS_PARAMS[9], FSRS_PARAMS[10]
    w15, w16 = FSRS_PARAMS[15], FSRS_PARAMS[16]

    hard_penalty = w15 if rating == RATING_HARD else 1.0
    easy_bonus = w16 if rating == RATING_EASY else 1.0

    factor = (
        math.exp(w8) *
        (11 - difficulty) *
        math.pow(stability, -w9) *
        (math.exp(w10 * (1 - retrievability)) - 1) *
        hard_penalty *
        easy_bonus +
        1
    )

    return stability * factor


def update_stability_forget(difficulty, stability, retrievability):
    """
    Update stability after forgetting (rating == 1 / Again).

    Formula:
    S'_f(D,S,R) = w11 * D^(-w12) * ((S+1)^w13 - 1) * e^(w14 * (1-R))
    """
    w11, w12, w13, w14 = FSRS_PARAMS[11], FSRS_PARAMS[12], FSRS_PARAMS[13], FSRS_PARAMS[14]

    new_stability = (
        w11 *
        math.pow(difficulty, -w12) *
        (math.pow(stability + 1, w13) - 1) *
        math.exp(w14 * (1 - retrievability))
    )

    # Ensure stability doesn't exceed pre-lapse stability
    return min(max(0.1, new_stability), stability)


def update_stability_same_day(stability, rating):
    """
    Update stability for same-day reviews (FSRS-6 short-term scheduler).

    Formula: S'(S,G) = S * e^(w17 * (G - 3 + w18)) * S^(-w19)
    """
    w17, w18, w19 = FSRS_PARAMS[17], FSRS_PARAMS[18], FSRS_PARAMS[19]

    new_stability = stability * math.exp(w17 * (rating - 3 + w18)) * math.pow(stability, -w19)

    return max(0.1, new_stability)


def process_review(problem, rating, review_date):
    """
    Process a review and return updated FSRS state.

    Args:
        problem: Problem dict with current FSRS state
        rating: User rating (1=Again, 2=Hard, 3=Good, 4=Easy)
        review_date: Date of review in YYYY-MM-DD format

    Returns:
        Tuple of (new_stability, new_difficulty, new_interval, new_state, retrievability)
    """
    state = problem.get("state", "new")
    stability = problem.get("stability", 0)
    difficulty = problem.get("difficulty", 5.0)
    last_review = problem.get("last_review_date")

    # Calculate elapsed days
    if last_review:
        last_date = datetime.strptime(last_review, "%Y-%m-%d")
        current_date = datetime.strptime(review_date, "%Y-%m-%d")
        elapsed_days = max(0, (current_date - last_date).days)
    else:
        elapsed_days = 0

    is_same_day = elapsed_days == 0 and last_review is not None

    # Calculate retrievability for this review
    if stability > 0 and elapsed_days > 0:
        retrievability = calculate_retrievability(elapsed_days, stability)
    else:
        retrievability = 0.9  # Default for new cards

    # Handle first review (new card)
    if state == "new" or stability <= 0:
        new_stability = get_initial_stability(rating)
        new_difficulty = get_initial_difficulty(rating)
        new_state = "learning" if rating == RATING_AGAIN else "review"

    # Handle same-day review
    elif is_same_day:
        new_stability = update_stability_same_day(stability, rating)
        new_difficulty = update_difficulty(difficulty, rating)
        new_state = "relearning" if rating == RATING_AGAIN else "review"

    # Handle regular review
    else:
        new_difficulty = update_difficulty(difficulty, rating)

        if rating == RATING_AGAIN:
            new_stability = update_stability_forget(difficulty, stability, retrievability)
            new_state = "relearning"
        else:
            new_stability = update_stability_success(
                difficulty, stability, retrievability, rating
            )
            new_state = "review"

    new_interval = calculate_interval(new_stability)

    return new_stability, new_difficulty, new_interval, new_state, retrievability


def rating_display(rating):
    """Get display string for FSRS rating."""
    if rating == RATING_AGAIN:
        return f"{Colors.MAGENTA}Again{Colors.RESET}"
    elif rating == RATING_HARD:
        return f"{Colors.RED}Hard{Colors.RESET}"
    elif rating == RATING_GOOD:
        return f"{Colors.YELLOW}Good{Colors.RESET}"
    elif rating == RATING_EASY:
        return f"{Colors.GREEN}Easy{Colors.RESET}"
    return f"{Colors.DIM}N/A{Colors.RESET}"


def calculate_current_retrievability(problem, today):
    """Calculate current retrievability for a problem."""
    # Handle new problems
    if problem.get('review_count', 0) == 0:
        return 0.9  # Default for unreviewed

    # Calculate elapsed days
    last_review = datetime.strptime(problem['last_review_date'], "%Y-%m-%d").date()
    elapsed = (today - last_review).days

    # Use FSRS-6 retrievability formula
    return calculate_retrievability(elapsed, problem['stability'])


def calculate_problem_weight(problem, today):
    """Calculate selection weight (higher = more likely to select)."""
    # Get current retrievability
    r = calculate_current_retrievability(problem, today)

    # Base weight
    weight = 1.0

    # Retrievability penalty (squared to heavily favor weak memories)
    weight += (1 - r) ** 2 * 10

    # Overdue bonus
    next_review = datetime.strptime(problem['next_review'], "%Y-%m-%d").date()
    overdue_days = (today - next_review).days
    if overdue_days > 0:
        weight += overdue_days * 0.5

    # Instability bonus (favor lower stability)
    weight += 1 / (problem['stability'] + 1)

    return weight, r


def get_selection_reason(problem, today, r):
    """Generate human-readable reason for selection."""
    # Check retrievability first (primary factor)
    if r < 0.8:
        return f"Low retrievability ({r*100:.1f}%)"

    # Check if overdue
    next_review = datetime.strptime(problem['next_review'], "%Y-%m-%d").date()
    overdue_days = (today - next_review).days
    if overdue_days > 0:
        return f"Overdue by {overdue_days} day{'s' if overdue_days > 1 else ''}"

    # Check low stability
    if problem['stability'] < 7:
        return f"Low stability ({problem['stability']:.1f}d)"

    return "Weighted random selection"


# ============================================================================
# Migration Functions (SM-2 to FSRS)
# ============================================================================

def migrate_problem_to_fsrs(old_problem):
    """Migrate a single problem from SM-2 to FSRS format."""

    # Rating conversion map: old (0-3) -> new (1-4)
    # Old: 0=Failed, 1=Easy, 2=Medium, 3=Hard
    # New: 1=Again, 2=Hard, 3=Good, 4=Easy
    rating_map = {0: 1, 1: 4, 2: 3, 3: 2}

    # Base fields (unchanged)
    new_problem = {
        "id": old_problem["id"],
        "name": old_problem["name"],
        "url": old_problem.get("url", ""),
        "added_date": old_problem["added_date"],
        "next_review": old_problem["next_review"],
        "review_count": old_problem["review_count"],
        "fsrs_version": 6,
        "migrated_from_sm2": True,
    }

    # Convert ease_factor [1.3, 3.0] to difficulty [1, 10]
    # Higher ease = easier = lower difficulty
    ease = old_problem.get("ease_factor", 2.5)
    new_problem["difficulty"] = clamp(10 - (ease - 1.3) / 1.7 * 9, 1.0, 10.0)

    # Stability = interval (approximation)
    interval = old_problem.get("interval", 1)
    new_problem["stability"] = max(0.5, float(interval))

    # Determine state
    if old_problem["review_count"] == 0:
        new_problem["state"] = "new"
    elif interval <= 1:
        new_problem["state"] = "learning"
    else:
        new_problem["state"] = "review"

    # Convert last_difficulty to last_rating
    old_diff = old_problem.get("last_difficulty")
    new_problem["last_rating"] = rating_map.get(old_diff) if old_diff is not None else None

    # Get last_review_date from history
    history = old_problem.get("history", [])
    new_problem["last_review_date"] = history[-1]["date"] if history else None

    # Count successful reviews for reps
    new_problem["reps"] = len([h for h in history if h.get("difficulty", 2) != 0])

    # Convert history entries
    new_history = []
    for entry in history:
        old_rating = entry.get("difficulty", 2)
        new_entry = {
            "date": entry["date"],
            "rating": rating_map.get(old_rating, 3),
            "interval": entry["interval"],
            "stability": float(entry["interval"]),
            "difficulty": new_problem["difficulty"],
            "retrievability": 0.9  # Assumed for migrated data
        }
        new_history.append(new_entry)
    new_problem["history"] = new_history

    return new_problem


def migrate_data_file(data):
    """Migrate entire data file from SM-2 to FSRS format."""
    new_data = {
        "problems": [],
        "daily_adds": data.get("daily_adds", {}),
        "fsrs_version": 6,
        "desired_retention": DESIRED_RETENTION,
    }

    for old_problem in data.get("problems", []):
        # Check if already migrated
        if old_problem.get("fsrs_version"):
            new_data["problems"].append(old_problem)
        else:
            new_problem = migrate_problem_to_fsrs(old_problem)
            new_data["problems"].append(new_problem)

    return new_data


# ============================================================================
# Data Management Functions
# ============================================================================

def load_data():
    """Load problems from JSON file with auto-migration to FSRS."""
    if DATA_FILE.exists():
        with open(DATA_FILE, "r") as f:
            data = json.load(f)

        # Check if migration to FSRS is needed
        if "fsrs_version" not in data:
            print(f"{Colors.YELLOW}Migrating data to FSRS-6 format...{Colors.RESET}")
            data = migrate_data_file(data)
            # Save migrated data immediately
            with open(DATA_FILE, "w") as f:
                json.dump(data, f, indent=2)
            print(f"{Colors.GREEN}Migration complete! {len(data['problems'])} problems migrated.{Colors.RESET}\n")

        # Ensure daily_adds exists
        if "daily_adds" not in data:
            data["daily_adds"] = {}
        return data

    return {
        "problems": [],
        "daily_adds": {},
        "fsrs_version": 6,
        "desired_retention": DESIRED_RETENTION
    }


def get_today_adds(data):
    """Get number of problems added today."""
    today = datetime.now().strftime("%Y-%m-%d")
    return data.get("daily_adds", {}).get(today, 0)


def increment_today_adds(data):
    """Increment the count of problems added today."""
    today = datetime.now().strftime("%Y-%m-%d")
    if "daily_adds" not in data:
        data["daily_adds"] = {}
    data["daily_adds"][today] = data["daily_adds"].get(today, 0) + 1


def get_due_count_by_date(data, date_str):
    """Get number of problems due on a specific date."""
    return len([p for p in data["problems"] if p["next_review"] == date_str])


def find_next_available_slot(data, start_days=1, max_days=7):
    """Find the next day with fewer than MAX_PRIORITY_PER_DAY problems due."""
    for days_ahead in range(start_days, start_days + max_days):
        check_date = (datetime.now() + timedelta(days=days_ahead)).strftime("%Y-%m-%d")
        if get_due_count_by_date(data, check_date) < MAX_PRIORITY_PER_DAY:
            return check_date, days_ahead
    # If all days are full, just use start_days
    return (datetime.now() + timedelta(days=start_days)).strftime("%Y-%m-%d"), start_days


def show_add_reminder(data):
    """Show reminder if fewer than MIN_ADDS_PER_DAY problems added today."""
    adds_today = get_today_adds(data)
    if adds_today < MIN_ADDS_PER_DAY:
        remaining = MIN_ADDS_PER_DAY - adds_today
        print(f"{Colors.YELLOW}Reminder: Add {remaining} more problem{'s' if remaining > 1 else ''} today (goal: {MIN_ADDS_PER_DAY}/day){Colors.RESET}\n")


def save_data(data):
    """Save problems to JSON file and sync to git if enabled."""
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=2)

    if GIT_SYNC_ENABLED:
        git_sync()


def git_sync():
    """Auto-commit and push changes to git if in a git repo."""
    try:
        # Check if we're in a git repo
        result = subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            cwd=SCRIPT_DIR,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return  # Not a git repo, skip silently

        # Check if there are changes to commit
        result = subprocess.run(
            ["git", "status", "--porcelain", DATA_FILE.name],
            cwd=SCRIPT_DIR,
            capture_output=True,
            text=True
        )
        if not result.stdout.strip():
            return  # No changes to commit

        # Stage the data file
        subprocess.run(
            ["git", "add", DATA_FILE.name],
            cwd=SCRIPT_DIR,
            capture_output=True
        )

        # Commit with timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        subprocess.run(
            ["git", "commit", "-m", f"leetcode-srs: auto-sync {timestamp}"],
            cwd=SCRIPT_DIR,
            capture_output=True
        )

        # Try to push (silently fail if no remote or offline)
        subprocess.run(
            ["git", "push"],
            cwd=SCRIPT_DIR,
            capture_output=True
        )

        print(f"{Colors.DIM}  [git synced]{Colors.RESET}")

    except FileNotFoundError:
        pass  # git not installed, skip silently
    except Exception:
        pass  # Any other error, skip silently


def format_date(date_str):
    """Format date string for display."""
    date = datetime.strptime(date_str, "%Y-%m-%d")
    today = datetime.now().date()
    delta = (date.date() - today).days

    if delta < 0:
        return f"{Colors.RED}Overdue by {-delta}d{Colors.RESET}"
    elif delta == 0:
        return f"{Colors.GREEN}Today{Colors.RESET}"
    elif delta == 1:
        return f"{Colors.YELLOW}Tomorrow{Colors.RESET}"
    else:
        return f"{Colors.BLUE}In {delta}d{Colors.RESET}"


def extract_problem_number(name):
    """Extract problem number from name like '171. Problem Name'."""
    match = re.match(r'^(\d+)\.', name)
    return int(match.group(1)) if match else None


def cmd_add(args):
    """Add a new problem to track."""
    if not args:
        print(f"{Colors.RED}Usage: leetcode-srs add <problem-name> [url]{Colors.RESET}")
        return

    name = args[0]
    url = args[1] if len(args) > 1 else ""

    # Validate problem name format
    problem_num = extract_problem_number(name)
    if problem_num is None:
        print(f"{Colors.RED}Error: Problem name must start with a number and dot (e.g., '171. Problem Name'){Colors.RESET}")
        return

    data = load_data()

    # Check for duplicate by problem number
    for existing in data["problems"]:
        existing_num = extract_problem_number(existing["name"])
        if existing_num == problem_num:
            print(f"{Colors.RED}Duplicate found:{Colors.RESET} '{existing['name']}' (#{existing_num})")
            print(f"  Next review: {format_date(existing['next_review'])}")
            print(f"  Reviews: {existing['review_count']}")
            return

    today = datetime.now()

    # Smart scheduling: find next day with available slot
    next_review, days_ahead = find_next_available_slot(data, start_days=1)

    # FSRS problem structure
    problem = {
        "id": str(uuid.uuid4())[:8],
        "name": name,
        "url": url,
        "added_date": today.strftime("%Y-%m-%d"),

        # FSRS fields
        "stability": 0,           # Will be set on first review
        "difficulty": 5.0,        # Default mid-range difficulty
        "state": "new",
        "last_review_date": None,
        "next_review": next_review,
        "reps": 0,

        # Tracking
        "review_count": 0,
        "last_rating": None,
        "history": [],

        # Metadata
        "fsrs_version": 6,
    }

    data["problems"].append(problem)
    increment_today_adds(data)
    save_data(data)

    print(f"{Colors.GREEN}Added:{Colors.RESET} {name}")
    if days_ahead == 1:
        print(f"  First review: {Colors.YELLOW}Tomorrow{Colors.RESET}")
    else:
        print(f"  First review: {Colors.BLUE}In {days_ahead} days{Colors.RESET} ({next_review})")

    # Show progress toward daily goal
    adds_today = get_today_adds(data)
    if adds_today >= MIN_ADDS_PER_DAY:
        print(f"  {Colors.GREEN}Daily goal reached! ({adds_today}/{MIN_ADDS_PER_DAY}){Colors.RESET}")
    else:
        print(f"  {Colors.DIM}Progress: {adds_today}/{MIN_ADDS_PER_DAY} problems added today{Colors.RESET}")


def cmd_today(args):
    """Show problems due for review today."""
    data = load_data()
    today = datetime.now().strftime("%Y-%m-%d")

    # Show add reminder first
    show_add_reminder(data)

    due = [p for p in data["problems"] if p["next_review"] <= today]
    # Sort by most overdue first (priority order)
    due.sort(key=lambda p: p["next_review"])

    if not due:
        print(f"{Colors.GREEN}No reviews due today! You're all caught up.{Colors.RESET}")
        return

    priority_count = min(len(due), MAX_PRIORITY_PER_DAY)
    extra_count = len(due) - priority_count

    if extra_count > 0:
        print(f"\n{Colors.BOLD}=== Due Today ({priority_count} priority + {extra_count} more) ==={Colors.RESET}\n")
    else:
        print(f"\n{Colors.BOLD}=== Due Today ({len(due)} problems) ==={Colors.RESET}\n")

    for i, p in enumerate(due):
        status = format_date(p["next_review"])

        # Calculate retrievability
        stability = p.get("stability", 0)
        last_review = p.get("last_review_date")
        if last_review and stability > 0:
            last_date = datetime.strptime(last_review, "%Y-%m-%d")
            elapsed = (datetime.now() - last_date).days
            r = calculate_retrievability(elapsed, stability)
            r_display = f"R:{r*100:.0f}%"
        else:
            r_display = "New"

        review_info = f"Review #{p['review_count'] + 1} | {r_display}"
        if p.get("last_rating") is not None:
            review_info += f" | Last: {rating_display(p['last_rating'])}"

        # Priority indicator for top MAX_PRIORITY_PER_DAY
        if i < MAX_PRIORITY_PER_DAY:
            priority_marker = f"{Colors.RED}[!]{Colors.RESET} "
        else:
            priority_marker = f"{Colors.DIM}[ ]{Colors.RESET} "

        print(f"  {priority_marker}{Colors.CYAN}{p['name']}{Colors.RESET}")
        print(f"      {status} | {review_info}")
        if p["url"]:
            print(f"      {Colors.DIM}{p['url']}{Colors.RESET}")
        print()


def cmd_review(args):
    """Interactive review session using FSRS algorithm."""
    data = load_data()
    today = datetime.now().strftime("%Y-%m-%d")

    # Show add reminder at start
    show_add_reminder(data)

    due = [p for p in data["problems"] if p["next_review"] <= today]
    # Sort by most overdue first (priority order)
    due.sort(key=lambda p: p["next_review"])

    if not due:
        print(f"{Colors.GREEN}No reviews due! Use 'leetcode-srs today' to check schedule.{Colors.RESET}")
        return

    priority_count = min(len(due), MAX_PRIORITY_PER_DAY)
    extra_count = len(due) - priority_count

    if extra_count > 0:
        print(f"{Colors.BOLD}=== Review Session ({priority_count} priority + {extra_count} more) ==={Colors.RESET}\n")
    else:
        print(f"{Colors.BOLD}=== Review Session ({len(due)} problems) ==={Colors.RESET}\n")

    for i, p in enumerate(due):
        # Priority indicator
        if i < MAX_PRIORITY_PER_DAY:
            priority_tag = f"{Colors.RED}[PRIORITY]{Colors.RESET} "
        else:
            priority_tag = ""

        # Calculate current retrievability
        stability = p.get("stability", 0)
        last_review = p.get("last_review_date")
        if last_review and stability > 0:
            last_date = datetime.strptime(last_review, "%Y-%m-%d")
            elapsed = (datetime.now() - last_date).days
            r = calculate_retrievability(elapsed, stability)
            r_display = f"R:{r*100:.0f}%"
        else:
            r_display = "New"

        print(f"{Colors.BOLD}[{i+1}/{len(due)}] {priority_tag}{p['name']}{Colors.RESET}")
        if p["url"]:
            print(f"  {Colors.DIM}{p['url']}{Colors.RESET}")
        print(f"  Review #{p['review_count'] + 1} | S:{stability:.1f}d | {r_display} | {format_date(p['next_review'])}")
        print()

        while True:
            print(f"  How did it go?")
            print(f"    {Colors.MAGENTA}1{Colors.RESET} - Again (forgot/couldn't solve)")
            print(f"    {Colors.RED}2{Colors.RESET} - Hard (struggled significantly)")
            print(f"    {Colors.YELLOW}3{Colors.RESET} - Good (some effort)")
            print(f"    {Colors.GREEN}4{Colors.RESET} - Easy (knew it quickly)")
            print(f"    {Colors.DIM}s{Colors.RESET} - Skip for now")
            print(f"    {Colors.DIM}q{Colors.RESET} - Quit review session")

            choice = input(f"\n  Your choice: ").strip().lower()

            if choice == 'q':
                print(f"\n{Colors.YELLOW}Review session ended.{Colors.RESET}")
                save_data(data)
                return
            elif choice == 's':
                print(f"{Colors.DIM}Skipped.{Colors.RESET}\n")
                break
            elif choice in ['1', '2', '3', '4']:
                rating = int(choice)

                # Process review with FSRS algorithm
                new_s, new_d, new_interval, new_state, retrievability = process_review(p, rating, today)
                next_date = (datetime.now() + timedelta(days=new_interval)).strftime("%Y-%m-%d")

                # Update problem with FSRS fields
                p["stability"] = new_s
                p["difficulty"] = new_d
                p["state"] = new_state
                p["next_review"] = next_date
                p["last_review_date"] = today
                p["review_count"] += 1
                p["last_rating"] = rating
                p["reps"] = p.get("reps", 0) + 1 if rating > RATING_AGAIN else 0
                p["history"].append({
                    "date": today,
                    "rating": rating,
                    "stability": new_s,
                    "difficulty": new_d,
                    "interval": new_interval,
                    "retrievability": retrievability
                })

                if rating == RATING_AGAIN:
                    print(f"\n  {Colors.MAGENTA}Again!{Colors.RESET} Stability: {Colors.CYAN}{new_s:.1f}d{Colors.RESET} | Next: {next_date}")
                else:
                    print(f"\n  {Colors.GREEN}Recorded!{Colors.RESET} Next review in {Colors.CYAN}{new_interval} days{Colors.RESET} (S:{new_s:.1f}d)")
                print()
                break
            else:
                print(f"  {Colors.RED}Invalid choice. Enter 1, 2, 3, 4, s, or q.{Colors.RESET}\n")

    save_data(data)
    print(f"{Colors.GREEN}Review session complete!{Colors.RESET}")


def cmd_list(args):
    """List all problems with their status."""
    data = load_data()

    if not data["problems"]:
        print(f"{Colors.YELLOW}No problems tracked yet. Use 'leetcode-srs add <name>' to add one.{Colors.RESET}")
        return

    # Sort by next review date
    problems = sorted(data["problems"], key=lambda p: p["next_review"])

    print(f"\n{Colors.BOLD}=== All Problems ({len(problems)}) ==={Colors.RESET}\n")

    for p in problems:
        status = format_date(p["next_review"])

        # Get FSRS fields
        s = p.get("stability", 0)
        d = p.get("difficulty", 5)
        last_review = p.get("last_review_date")

        # Calculate current retrievability
        if last_review and s > 0:
            last_date = datetime.strptime(last_review, "%Y-%m-%d")
            elapsed = (datetime.now() - last_date).days
            r = calculate_retrievability(elapsed, s)
            r_display = f"R:{r*100:.0f}%"
        else:
            r_display = "New"

        print(f"  {Colors.CYAN}{p['name']}{Colors.RESET}")
        print(f"    {status} | S:{s:.1f}d | D:{d:.1f} | {r_display} | Reviews: {p['review_count']}")
        if p["url"]:
            print(f"    {Colors.DIM}{p['url']}{Colors.RESET}")
        print()


def cmd_stats(args):
    """Show learning statistics."""
    data = load_data()

    if not data["problems"]:
        print(f"{Colors.YELLOW}No problems tracked yet.{Colors.RESET}")
        return

    problems = data["problems"]
    today = datetime.now().strftime("%Y-%m-%d")

    total = len(problems)
    due_today = len([p for p in problems if p["next_review"] <= today])
    total_reviews = sum(p["review_count"] for p in problems)

    # Problems by stability ranges (FSRS maturity)
    learning = len([p for p in problems if p.get("stability", 0) <= 4])
    young = len([p for p in problems if 4 < p.get("stability", 0) <= 21])
    mature = len([p for p in problems if p.get("stability", 0) > 21])

    print(f"\n{Colors.BOLD}=== Statistics (FSRS-6) ==={Colors.RESET}\n")
    print(f"  Total problems:    {Colors.CYAN}{total}{Colors.RESET}")
    print(f"  Due today:         {Colors.YELLOW if due_today else Colors.GREEN}{due_today}{Colors.RESET}")
    print(f"  Total reviews:     {Colors.CYAN}{total_reviews}{Colors.RESET}")
    print()

    # Averages
    if problems:
        avg_s = sum(p.get("stability", 0) for p in problems) / len(problems)
        avg_d = sum(p.get("difficulty", 5) for p in problems) / len(problems)
        print(f"  {Colors.BOLD}Averages:{Colors.RESET}")
        print(f"    Stability:   {Colors.CYAN}{avg_s:.1f}d{Colors.RESET}")
        print(f"    Difficulty:  {Colors.CYAN}{avg_d:.1f}{Colors.RESET}")
        print()

    print(f"  {Colors.BOLD}Problem Maturity (by Stability):{Colors.RESET}")
    print(f"    Learning (S<=4d):  {Colors.RED}{learning}{Colors.RESET}")
    print(f"    Young (4<S<=21d):  {Colors.YELLOW}{young}{Colors.RESET}")
    print(f"    Mature (S>21d):    {Colors.GREEN}{mature}{Colors.RESET}")
    print()

    # Upcoming reviews
    upcoming = {}
    for p in problems:
        next_date = p["next_review"]
        delta = (datetime.strptime(next_date, "%Y-%m-%d").date() - datetime.now().date()).days
        if delta <= 7:
            key = max(0, delta)
            upcoming[key] = upcoming.get(key, 0) + 1

    if upcoming:
        print(f"  {Colors.BOLD}Next 7 Days:{Colors.RESET}")
        days = ["Today", "Tomorrow"] + [f"Day {i}" for i in range(2, 8)]
        for i in range(8):
            if i in upcoming:
                bar = "=" * upcoming[i]
                print(f"    {days[i]:10} {Colors.BLUE}{bar}{Colors.RESET} {upcoming[i]}")
    print()


def cmd_delete(args):
    """Delete a problem."""
    if not args:
        print(f"{Colors.RED}Usage: leetcode-srs delete <problem-name-or-id>{Colors.RESET}")
        return

    search = args[0].lower()
    data = load_data()

    # Find matching problems
    matches = [p for p in data["problems"]
               if search in p["name"].lower() or search == p["id"]]

    if not matches:
        print(f"{Colors.RED}No problem found matching '{args[0]}'{Colors.RESET}")
        return

    if len(matches) > 1:
        print(f"{Colors.YELLOW}Multiple matches found:{Colors.RESET}")
        for p in matches:
            print(f"  [{p['id']}] {p['name']}")
        print(f"\nUse the ID to delete a specific problem.")
        return

    problem = matches[0]
    confirm = input(f"Delete '{problem['name']}'? (y/N): ").strip().lower()

    if confirm == 'y':
        data["problems"] = [p for p in data["problems"] if p["id"] != problem["id"]]
        save_data(data)
        print(f"{Colors.GREEN}Deleted: {problem['name']}{Colors.RESET}")
    else:
        print(f"{Colors.DIM}Cancelled.{Colors.RESET}")


def cmd_sync(args):
    """Manually sync to git."""
    # Check if we're in a git repo
    result = subprocess.run(
        ["git", "rev-parse", "--is-inside-work-tree"],
        cwd=SCRIPT_DIR,
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print(f"{Colors.YELLOW}Not a git repository. Initialize with 'git init' first.{Colors.RESET}")
        return

    # Check if data file exists
    if not DATA_FILE.exists():
        print(f"{Colors.YELLOW}No data file yet. Add some problems first.{Colors.RESET}")
        return

    # Stage and commit
    subprocess.run(["git", "add", DATA_FILE.name], cwd=SCRIPT_DIR, capture_output=True)

    result = subprocess.run(
        ["git", "status", "--porcelain", DATA_FILE.name],
        cwd=SCRIPT_DIR,
        capture_output=True,
        text=True
    )

    if not result.stdout.strip():
        print(f"{Colors.GREEN}Already in sync, no changes to commit.{Colors.RESET}")
    else:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        subprocess.run(
            ["git", "commit", "-m", f"leetcode-srs: manual sync {timestamp}"],
            cwd=SCRIPT_DIR,
            capture_output=True
        )
        print(f"{Colors.GREEN}Committed changes.{Colors.RESET}")

    # Try to push
    result = subprocess.run(
        ["git", "push"],
        cwd=SCRIPT_DIR,
        capture_output=True,
        text=True
    )
    if result.returncode == 0:
        print(f"{Colors.GREEN}Pushed to remote.{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}Could not push (no remote or offline).{Colors.RESET}")


def cmd_random(args):
    """Select random problem(s) weighted by memory weakness."""
    import random

    data = load_data()

    if not data["problems"]:
        print(f"{Colors.YELLOW}No problems yet. Add some with 'leetcode-srs add'.{Colors.RESET}")
        return

    # Parse arguments
    count = 1
    include_new = False
    start_review = False

    i = 0
    while i < len(args):
        arg = args[i]
        if arg == "--include-new":
            include_new = True
        elif arg == "--review":
            start_review = True
        elif arg.isdigit():
            count = int(arg)
        else:
            print(f"{Colors.RED}Unknown argument: {arg}{Colors.RESET}")
            print(f"Usage: leetcode-srs random [count] [--review] [--include-new]")
            return
        i += 1

    # Filter eligible problems
    today = datetime.now().date()
    eligible = []

    for p in data["problems"]:
        # Exclude new problems unless flag set
        if not include_new and p.get('state') == 'new':
            continue
        eligible.append(p)

    if not eligible:
        print(f"{Colors.YELLOW}No eligible problems for random selection.{Colors.RESET}")
        if not include_new:
            print(f"{Colors.DIM}Tip: Use --include-new to include unreviewed problems.{Colors.RESET}")
        return

    # Cap count at available
    count = min(count, len(eligible))

    # Calculate weights for all eligible problems
    weights = []
    retrievabilities = []
    for p in eligible:
        weight, r = calculate_problem_weight(p, today)
        weights.append(weight)
        retrievabilities.append(r)

    # Weighted random selection
    selected_indices = random.choices(range(len(eligible)), weights=weights, k=count)
    selected_problems = [eligible[i] for i in selected_indices]
    selected_retrievabilities = [retrievabilities[i] for i in selected_indices]

    # Display
    if count == 1:
        problem = selected_problems[0]
        r = selected_retrievabilities[0]

        print(f"\n{Colors.BOLD}=== Random Problem Selected ==={Colors.RESET}\n")
        print(f"  {Colors.CYAN}{problem['name']}{Colors.RESET}")
        print(f"  {Colors.DIM}{problem['url']}{Colors.RESET}")
        print()
        print(f"  Selection Reason: {get_selection_reason(problem, today, r)}")
        print()

        # Prompt for review if not auto-starting
        if not start_review:
            response = input("Would you like to review this now? (y/N): ").strip().lower()
            if response == 'y':
                start_review = True

        # Review the selected problem
        if start_review:
            today_str = datetime.now().strftime("%Y-%m-%d")

            # Show problem info
            stability = problem.get("stability", 0)
            print(f"{Colors.BOLD}Reviewing: {problem['name']}{Colors.RESET}")
            print(f"  Review #{problem['review_count'] + 1} | S:{stability:.1f}d | R:{r*100:.0f}%")
            print()

            while True:
                print(f"  How did it go?")
                print(f"    {Colors.MAGENTA}1{Colors.RESET} - Again (forgot/couldn't solve)")
                print(f"    {Colors.RED}2{Colors.RESET} - Hard (struggled significantly)")
                print(f"    {Colors.YELLOW}3{Colors.RESET} - Good (some effort)")
                print(f"    {Colors.GREEN}4{Colors.RESET} - Easy (knew it quickly)")
                print(f"    {Colors.DIM}s{Colors.RESET} - Skip this review")

                choice = input(f"\n  Your choice: ").strip().lower()

                if choice == 's':
                    print(f"{Colors.DIM}Skipped.{Colors.RESET}\n")
                    break
                elif choice in ['1', '2', '3', '4']:
                    rating = int(choice)

                    # Process review with FSRS algorithm
                    new_s, new_d, new_interval, new_state, retrievability = process_review(problem, rating, today_str)
                    next_date = (datetime.now() + timedelta(days=new_interval)).strftime("%Y-%m-%d")

                    # Update problem with FSRS fields
                    problem["stability"] = new_s
                    problem["difficulty"] = new_d
                    problem["state"] = new_state
                    problem["next_review"] = next_date
                    problem["last_review_date"] = today_str
                    problem["review_count"] += 1
                    problem["last_rating"] = rating
                    problem["reps"] = problem.get("reps", 0) + 1 if rating > RATING_AGAIN else 0
                    problem["history"].append({
                        "date": today_str,
                        "rating": rating,
                        "stability": new_s,
                        "difficulty": new_d,
                        "interval": new_interval,
                        "retrievability": retrievability
                    })

                    # Save data
                    save_data(data)

                    if rating == RATING_AGAIN:
                        print(f"\n  {Colors.MAGENTA}Again!{Colors.RESET} Stability: {Colors.CYAN}{new_s:.1f}d{Colors.RESET} | Next: {next_date}")
                    else:
                        print(f"\n  {Colors.GREEN}Recorded!{Colors.RESET} Next review in {Colors.CYAN}{new_interval} days{Colors.RESET} (S:{new_s:.1f}d)")
                    print()
                    break
                else:
                    print(f"  {Colors.RED}Invalid choice. Enter 1, 2, 3, 4, or s.{Colors.RESET}\n")
    else:
        print(f"\n{Colors.BOLD}=== {count} Random Problems Selected ==={Colors.RESET}\n")
        for i, (problem, r) in enumerate(zip(selected_problems, selected_retrievabilities), 1):
            reason = get_selection_reason(problem, today, r)
            print(f"{i}. {Colors.CYAN}{problem['name']}{Colors.RESET}")
            print(f"   {Colors.DIM}{problem['url']}{Colors.RESET}")
            print(f"   {reason}")
            print()


def cmd_help(args):
    """Show help message."""
    sync_status = f"{Colors.GREEN}ON{Colors.RESET}" if GIT_SYNC_ENABLED else f"{Colors.RED}OFF{Colors.RESET}"
    print(f"""
{Colors.BOLD}LeetCode Spaced Repetition System (FSRS-6){Colors.RESET}

{Colors.BOLD}Usage:{Colors.RESET}
  leetcode-srs <command> [arguments]

{Colors.BOLD}Commands:{Colors.RESET}
  {Colors.CYAN}add{Colors.RESET} <name> [url]   Add a new problem to track
  {Colors.CYAN}today{Colors.RESET}              Show problems due for review today
  {Colors.CYAN}review{Colors.RESET}             Start interactive review session
  {Colors.CYAN}list{Colors.RESET}               List all problems with status
  {Colors.CYAN}stats{Colors.RESET}              Show learning statistics
  {Colors.CYAN}delete{Colors.RESET} <name|id>   Delete a problem
  {Colors.CYAN}random{Colors.RESET} [count]     Select problem(s) by memory weakness
  {Colors.CYAN}sync{Colors.RESET}               Manually sync to git
  {Colors.CYAN}help{Colors.RESET}               Show this help message

{Colors.BOLD}Algorithm (FSRS-6):{Colors.RESET}
  Uses the Free Spaced Repetition Scheduler with:
  - {Colors.CYAN}Stability (S){Colors.RESET}: Memory strength in days (time to drop to 90% recall)
  - {Colors.CYAN}Difficulty (D){Colors.RESET}: Problem complexity [1-10]
  - {Colors.CYAN}Retrievability (R){Colors.RESET}: Current recall probability [0-100%]

{Colors.BOLD}Rating Scale:{Colors.RESET}
  {Colors.MAGENTA}1 - Again{Colors.RESET}:  Forgot or couldn't solve (resets learning)
  {Colors.RED}2 - Hard{Colors.RESET}:   Struggled significantly (reduced stability gain)
  {Colors.YELLOW}3 - Good{Colors.RESET}:   Normal recall with effort (standard progression)
  {Colors.GREEN}4 - Easy{Colors.RESET}:   Instant recall (accelerated progression)

{Colors.BOLD}Key Concepts:{Colors.RESET}
  - Target retention: 90% (reviews scheduled before memory fades)
  - Interval = time for retrievability to drop to target
  - Difficulty adapts based on your performance history
  - Same-day reviews use short-term memory model

{Colors.BOLD}Interval Progression Example (Good ratings):{Colors.RESET}
  1d -> 2d -> 5d -> 12d -> 28d -> 65d -> 150d ...
  (actual intervals depend on difficulty and consistency)

{Colors.BOLD}Daily Goals:{Colors.RESET}
  - Add at least {MIN_ADDS_PER_DAY} new problems per day
  - Top {MAX_PRIORITY_PER_DAY} most urgent problems marked as [!] priority
  - Smart scheduling spreads new problems to prevent clustering

{Colors.BOLD}Git Sync:{Colors.RESET}
  Auto-sync: {sync_status} (edit GIT_SYNC_ENABLED in script to change)
  Data auto-commits and pushes after each change when in a git repo.

{Colors.BOLD}Example Workflow:{Colors.RESET}
  leetcode-srs add "Two Sum" "https://leetcode.com/problems/two-sum"
  leetcode-srs today
  leetcode-srs review

{Colors.DIM}Data stored at: {DATA_FILE}{Colors.RESET}
{Colors.DIM}Algorithm: FSRS-6 (https://github.com/open-spaced-repetition){Colors.RESET}
""")


def main():
    """Main entry point."""
    commands = {
        "add": cmd_add,
        "today": cmd_today,
        "review": cmd_review,
        "list": cmd_list,
        "stats": cmd_stats,
        "delete": cmd_delete,
        "random": cmd_random,
        "sync": cmd_sync,
        "help": cmd_help,
    }

    if len(sys.argv) < 2:
        cmd_today([])
        return

    cmd = sys.argv[1].lower()
    args = sys.argv[2:]

    if cmd in commands:
        commands[cmd](args)
    else:
        print(f"{Colors.RED}Unknown command: {cmd}{Colors.RESET}")
        print(f"Use 'leetcode-srs help' for available commands.")


if __name__ == "__main__":
    main()
