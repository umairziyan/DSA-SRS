#!/usr/bin/env python3
"""
System Design Spaced Repetition System (SRS) CLI Tool

A simple CLI to track System Design questions using spaced repetition
with the FSRS-6 (Free Spaced Repetition Scheduler) algorithm.

FSRS is a modern spaced repetition algorithm that models memory with:
- Stability (S): Time in days for retrievability to drop to 90%
- Difficulty (D): Inherent complexity of the material [1-10]
- Retrievability (R): Current probability of recall [0-1]

See: https://github.com/open-spaced-repetition/fsrs4anki
"""

import json
import os
import re
import subprocess
import sys
import uuid
from datetime import datetime, timedelta
from pathlib import Path

# Store data in the same folder as the script
SCRIPT_DIR = Path(__file__).resolve().parent
DATA_FILE = SCRIPT_DIR / "systemdesign-srs-data.json"

# Git sync settings
GIT_SYNC_ENABLED = True  # Set to False to disable auto-sync

# Daily limits (conservative for longer study sessions)
MAX_NEW_PER_DAY = 1       # Maximum new questions to add daily
MAX_REVIEWS_PER_DAY = 1   # Maximum reviews per day
MAX_DUE_PER_DAY = 1       # Maximum questions due on any single day

# FSRS-6 Algorithm Parameters (21 total)
# See: https://github.com/open-spaced-repetition/fsrs4anki/wiki/The-Algorithm
FSRS_PARAMS = [
    0.212,    # w0:  S0(1) - initial stability for Again
    1.2931,   # w1:  S0(2) - initial stability for Hard
    2.3065,   # w2:  S0(3) - initial stability for Good
    8.2956,   # w3:  S0(4) - initial stability for Easy
    6.4133,   # w4:  D0 base - initial difficulty calculation
    0.8334,   # w5:  D0 scale - initial difficulty calculation
    3.0194,   # w6:  Difficulty delta factor
    0.001,    # w7:  Mean reversion weight
    1.8722,   # w8:  Stability recall factor
    0.1666,   # w9:  Stability recall exponent
    0.796,    # w10: Stability recall retrievability factor
    1.4835,   # w11: Stability forget factor
    0.0614,   # w12: Stability forget difficulty exponent
    0.2629,   # w13: Stability forget stability exponent
    1.6483,   # w14: Stability forget retrievability factor
    0.6014,   # w15: Hard penalty
    1.8729,   # w16: Easy bonus
    0.5425,   # w17: Same-day stability factor
    0.0912,   # w18: Same-day rating offset
    0.0658,   # w19: Same-day stability exponent
    0.1542    # w20: Reserved for future use
]

# FSRS Constants
FSRS_FACTOR = 19 / 81  # F constant for retrievability formula
FSRS_DECAY = -0.5      # C constant for retrievability formula
DESIRED_RETENTION = 0.9  # Target recall probability (90%)

# Rating constants (FSRS uses 1-4, not 0-3)
RATING_AGAIN = 1
RATING_HARD = 2
RATING_GOOD = 3
RATING_EASY = 4

# Colors for terminal output
class Colors:
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    CYAN = "\033[96m"
    BOLD = "\033[1m"
    DIM = "\033[2m"
    RESET = "\033[0m"


# ============================================================================
# FSRS-6 Algorithm Functions
# ============================================================================

import math

def clamp(value, min_val, max_val):
    """Clamp value to range [min_val, max_val]."""
    return max(min_val, min(max_val, value))


def calculate_retrievability(elapsed_days, stability):
    """
    Calculate retrievability (probability of recall).

    Formula: R(t, S) = (1 + F * (t/S))^C
    Where: F = 19/81, C = -0.5

    Returns: Retrievability R in range [0, 1]
    """
    if stability <= 0:
        return 0.0
    return math.pow(1 + FSRS_FACTOR * (elapsed_days / stability), FSRS_DECAY)


def calculate_interval(stability, desired_retention=DESIRED_RETENTION):
    """
    Calculate optimal review interval from stability.

    Formula: I = S * ln(desired_retention) / ln(0.9)
    Note: When desired_retention = 0.9, interval equals stability.

    Returns: Interval in whole days (minimum 1)
    """
    if stability <= 0:
        return 1
    interval = stability * math.log(desired_retention) / math.log(0.9)
    return max(1, round(interval))


def get_initial_stability(rating):
    """
    Get initial stability for first review.

    Formula: S0(G) = w[G-1] for G in {1, 2, 3, 4}
    """
    if rating < 1 or rating > 4:
        rating = 3  # Default to Good
    return FSRS_PARAMS[rating - 1]


def get_initial_difficulty(rating):
    """
    Calculate initial difficulty.

    Formula: D0(G) = w4 - e^(w5 * (G-1)) + 1
    Clamped to range [1, 10]
    """
    w4, w5 = FSRS_PARAMS[4], FSRS_PARAMS[5]
    d0 = w4 - math.exp(w5 * (rating - 1)) + 1
    return clamp(d0, 1.0, 10.0)


def update_difficulty(difficulty, rating):
    """
    Update difficulty after a review.

    Step 1: delta_D = -w6 * (G - 3)
    Step 2: D' = D + delta_D * (10 - D) / 9
    Step 3: Mean reversion: D'' = w7 * D0(4) + (1 - w7) * D'

    Returns: Updated difficulty D'' in range [1, 10]
    """
    w6, w7 = FSRS_PARAMS[6], FSRS_PARAMS[7]

    # Step 1: Calculate delta
    delta_d = -w6 * (rating - 3)

    # Step 2: Apply delta with scaling factor
    d_prime = difficulty + delta_d * (10 - difficulty) / 9

    # Step 3: Mean reversion toward D0(4)
    d0_4 = get_initial_difficulty(4)
    d_new = w7 * d0_4 + (1 - w7) * d_prime

    return clamp(d_new, 1.0, 10.0)


def update_stability_success(difficulty, stability, retrievability, rating):
    """
    Update stability after successful recall (rating >= 2).

    Formula:
    S'_r(D,S,R,G) = S * (e^w8 * (11-D) * S^(-w9) * (e^(w10*(1-R))-1)
                        * hard_penalty * easy_bonus + 1)
    """
    w8, w9, w10 = FSRS_PARAMS[8], FSRS_PARAMS[9], FSRS_PARAMS[10]
    w15, w16 = FSRS_PARAMS[15], FSRS_PARAMS[16]

    hard_penalty = w15 if rating == RATING_HARD else 1.0
    easy_bonus = w16 if rating == RATING_EASY else 1.0

    factor = (
        math.exp(w8) *
        (11 - difficulty) *
        math.pow(stability, -w9) *
        (math.exp(w10 * (1 - retrievability)) - 1) *
        hard_penalty *
        easy_bonus +
        1
    )

    return stability * factor


def update_stability_forget(difficulty, stability, retrievability):
    """
    Update stability after forgetting (rating == 1 / Again).

    Formula:
    S'_f(D,S,R) = w11 * D^(-w12) * ((S+1)^w13 - 1) * e^(w14 * (1-R))
    """
    w11, w12, w13, w14 = FSRS_PARAMS[11], FSRS_PARAMS[12], FSRS_PARAMS[13], FSRS_PARAMS[14]

    new_stability = (
        w11 *
        math.pow(difficulty, -w12) *
        (math.pow(stability + 1, w13) - 1) *
        math.exp(w14 * (1 - retrievability))
    )

    # Ensure stability doesn't exceed pre-lapse stability
    return min(max(0.1, new_stability), stability)


def update_stability_same_day(stability, rating):
    """
    Update stability for same-day reviews (FSRS-6 short-term scheduler).

    Formula: S'(S,G) = S * e^(w17 * (G - 3 + w18)) * S^(-w19)
    """
    w17, w18, w19 = FSRS_PARAMS[17], FSRS_PARAMS[18], FSRS_PARAMS[19]

    new_stability = stability * math.exp(w17 * (rating - 3 + w18)) * math.pow(stability, -w19)

    return max(0.1, new_stability)


def process_review(question, rating, review_date):
    """
    Process a review and return updated FSRS state.

    Args:
        question: Question dict with current FSRS state
        rating: User rating (1=Again, 2=Hard, 3=Good, 4=Easy)
        review_date: Date of review in YYYY-MM-DD format

    Returns:
        Tuple of (new_stability, new_difficulty, new_interval, new_state, retrievability)
    """
    state = question.get("state", "new")
    stability = question.get("stability", 0)
    difficulty = question.get("difficulty", 5.0)
    last_review = question.get("last_review_date")

    # Calculate elapsed days
    if last_review:
        last_date = datetime.strptime(last_review, "%Y-%m-%d")
        current_date = datetime.strptime(review_date, "%Y-%m-%d")
        elapsed_days = max(0, (current_date - last_date).days)
    else:
        elapsed_days = 0

    is_same_day = elapsed_days == 0 and last_review is not None

    # Calculate retrievability for this review
    if stability > 0 and elapsed_days > 0:
        retrievability = calculate_retrievability(elapsed_days, stability)
    else:
        retrievability = 0.9  # Default for new cards

    # Handle first review (new card)
    if state == "new" or stability <= 0:
        new_stability = get_initial_stability(rating)
        new_difficulty = get_initial_difficulty(rating)
        new_state = "learning" if rating == RATING_AGAIN else "review"

    # Handle same-day review
    elif is_same_day:
        new_stability = update_stability_same_day(stability, rating)
        new_difficulty = update_difficulty(difficulty, rating)
        new_state = "relearning" if rating == RATING_AGAIN else "review"

    # Handle regular review
    else:
        new_difficulty = update_difficulty(difficulty, rating)

        if rating == RATING_AGAIN:
            new_stability = update_stability_forget(difficulty, stability, retrievability)
            new_state = "relearning"
        else:
            new_stability = update_stability_success(
                difficulty, stability, retrievability, rating
            )
            new_state = "review"

    new_interval = calculate_interval(new_stability)

    return new_stability, new_difficulty, new_interval, new_state, retrievability


def rating_display(rating):
    """Get display string for FSRS rating."""
    if rating == RATING_AGAIN:
        return f"{Colors.MAGENTA}Again{Colors.RESET}"
    elif rating == RATING_HARD:
        return f"{Colors.RED}Hard{Colors.RESET}"
    elif rating == RATING_GOOD:
        return f"{Colors.YELLOW}Good{Colors.RESET}"
    elif rating == RATING_EASY:
        return f"{Colors.GREEN}Easy{Colors.RESET}"
    return f"{Colors.DIM}N/A{Colors.RESET}"


def calculate_current_retrievability(question, today):
    """Calculate current retrievability for a question."""
    # Handle new questions
    if question.get('review_count', 0) == 0:
        return 0.9  # Default for unreviewed

    # Calculate elapsed days
    last_review = datetime.strptime(question['last_review_date'], "%Y-%m-%d").date()
    elapsed = (today - last_review).days

    # Use FSRS-6 retrievability formula
    return calculate_retrievability(elapsed, question['stability'])


def calculate_question_weight(question, today):
    """Calculate selection weight (higher = more likely to select)."""
    # Get current retrievability
    r = calculate_current_retrievability(question, today)

    # Base weight
    weight = 1.0

    # Retrievability penalty (squared to heavily favor weak memories)
    weight += (1 - r) ** 2 * 10

    # Overdue bonus
    next_review = datetime.strptime(question['next_review'], "%Y-%m-%d").date()
    overdue_days = (today - next_review).days
    if overdue_days > 0:
        weight += overdue_days * 0.5

    # Instability bonus (favor lower stability)
    weight += 1 / (question['stability'] + 1)

    return weight, r


def get_selection_reason(question, today, r):
    """Generate human-readable reason for selection."""
    # Check retrievability first (primary factor)
    if r < 0.8:
        return f"Low retrievability ({r*100:.1f}%)"

    # Check if overdue
    next_review = datetime.strptime(question['next_review'], "%Y-%m-%d").date()
    overdue_days = (today - next_review).days
    if overdue_days > 0:
        return f"Overdue by {overdue_days} day{'s' if overdue_days > 1 else ''}"

    # Check low stability
    if question['stability'] < 7:
        return f"Low stability ({question['stability']:.1f}d)"

    return "Weighted random selection"


# ============================================================================
# Data Management Functions
# ============================================================================

def load_data():
    """Load questions from JSON file."""
    if DATA_FILE.exists():
        with open(DATA_FILE, "r") as f:
            data = json.load(f)

        # Ensure required fields exist
        if "daily_adds" not in data:
            data["daily_adds"] = {}
        if "daily_reviews" not in data:
            data["daily_reviews"] = {}
        return data

    return {
        "questions": [],
        "daily_adds": {},
        "daily_reviews": {},
        "fsrs_version": 6,
        "desired_retention": DESIRED_RETENTION
    }


def get_today_adds(data):
    """Get number of questions added today."""
    today = datetime.now().strftime("%Y-%m-%d")
    return data.get("daily_adds", {}).get(today, 0)


def increment_today_adds(data):
    """Increment the count of questions added today."""
    today = datetime.now().strftime("%Y-%m-%d")
    if "daily_adds" not in data:
        data["daily_adds"] = {}
    data["daily_adds"][today] = data["daily_adds"].get(today, 0) + 1


def get_today_reviews(data):
    """Get number of reviews completed today."""
    today = datetime.now().strftime("%Y-%m-%d")
    return data.get("daily_reviews", {}).get(today, 0)


def increment_today_reviews(data):
    """Increment the count of reviews completed today."""
    today = datetime.now().strftime("%Y-%m-%d")
    if "daily_reviews" not in data:
        data["daily_reviews"] = {}
    data["daily_reviews"][today] = data["daily_reviews"].get(today, 0) + 1


def get_due_count_by_date(data, date_str):
    """Get number of questions due on a specific date."""
    return len([q for q in data["questions"] if q["next_review"] == date_str])


def schedule_next_review(data, calculated_interval):
    """
    Schedule review on next available day (max MAX_DUE_PER_DAY per day).

    FSRS handles delayed reviews gracefully - the algorithm adapts based on
    actual elapsed time, and the spacing effect can even increase stability
    for delayed successful reviews.
    """
    target_date = datetime.now() + timedelta(days=calculated_interval)

    # Find the next day with < MAX_DUE_PER_DAY questions
    for offset in range(0, 30):  # Search up to 30 days ahead
        check_date = (target_date + timedelta(days=offset)).strftime("%Y-%m-%d")
        if get_due_count_by_date(data, check_date) < MAX_DUE_PER_DAY:
            return check_date

    # If all days are full, use the original target date
    return target_date.strftime("%Y-%m-%d")


def show_add_status(data):
    """Show status of daily add limit."""
    adds_today = get_today_adds(data)
    if adds_today >= MAX_NEW_PER_DAY:
        print(f"{Colors.GREEN}Daily add limit reached ({adds_today}/{MAX_NEW_PER_DAY}){Colors.RESET}\n")
    else:
        remaining = MAX_NEW_PER_DAY - adds_today
        print(f"{Colors.DIM}You can add {remaining} more question{'s' if remaining > 1 else ''} today ({adds_today}/{MAX_NEW_PER_DAY}){Colors.RESET}\n")


def save_data(data):
    """Save questions to JSON file and sync to git if enabled."""
    with open(DATA_FILE, "w") as f:
        json.dump(data, f, indent=2)

    if GIT_SYNC_ENABLED:
        git_sync()


def git_sync():
    """Auto-commit and push changes to git if in a git repo."""
    try:
        # Check if we're in a git repo
        result = subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            cwd=SCRIPT_DIR,
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            return  # Not a git repo, skip silently

        # Check if there are changes to commit
        result = subprocess.run(
            ["git", "status", "--porcelain", DATA_FILE.name],
            cwd=SCRIPT_DIR,
            capture_output=True,
            text=True
        )
        if not result.stdout.strip():
            return  # No changes to commit

        # Stage the data file
        subprocess.run(
            ["git", "add", DATA_FILE.name],
            cwd=SCRIPT_DIR,
            capture_output=True
        )

        # Commit with timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        subprocess.run(
            ["git", "commit", "-m", f"systemdesign-srs: auto-sync {timestamp}"],
            cwd=SCRIPT_DIR,
            capture_output=True
        )

        # Try to push (silently fail if no remote or offline)
        push_result = subprocess.run(
            ["git", "push"],
            cwd=SCRIPT_DIR,
            capture_output=True
        )

        if push_result.returncode == 0:
            print(f"{Colors.DIM}  [git synced]{Colors.RESET}")
        else:
            print(f"{Colors.DIM}  [git committed, push failed]{Colors.RESET}")

    except FileNotFoundError:
        pass  # git not installed, skip silently
    except Exception:
        pass  # Any other error, skip silently


def format_date(date_str):
    """Format date string for display."""
    date = datetime.strptime(date_str, "%Y-%m-%d")
    today = datetime.now().date()
    delta = (date.date() - today).days

    if delta < 0:
        return f"{Colors.RED}Overdue by {-delta}d{Colors.RESET}"
    elif delta == 0:
        return f"{Colors.GREEN}Today{Colors.RESET}"
    elif delta == 1:
        return f"{Colors.YELLOW}Tomorrow{Colors.RESET}"
    else:
        return f"{Colors.BLUE}In {delta}d{Colors.RESET}"


def format_last_review(date_str):
    """Format last review date for display."""
    if not date_str:
        return f"{Colors.DIM}Never{Colors.RESET}"
    date = datetime.strptime(date_str, "%Y-%m-%d")
    today = datetime.now().date()
    delta = (today - date.date()).days

    if delta == 0:
        return f"{Colors.GREEN}Today{Colors.RESET}"
    elif delta == 1:
        return f"{Colors.DIM}1d ago{Colors.RESET}"
    else:
        return f"{Colors.DIM}{delta}d ago{Colors.RESET}"


def cmd_add(args):
    """Add a new system design question to track."""
    if not args:
        print(f"{Colors.RED}Usage: systemdesign-srs add <question-name> [url]{Colors.RESET}")
        return

    name = args[0]
    url = args[1] if len(args) > 1 else ""

    data = load_data()

    # Check for duplicate by name
    for existing in data["questions"]:
        if existing["name"].lower() == name.lower():
            print(f"{Colors.RED}Duplicate found:{Colors.RESET} '{existing['name']}'")
            print(f"  Next review: {format_date(existing['next_review'])}")
            print(f"  Reviews: {existing['review_count']}")
            return

    # Warn if daily add limit reached
    adds_today = get_today_adds(data)
    if adds_today >= MAX_NEW_PER_DAY:
        print(f"{Colors.YELLOW}Warning: You've already added {adds_today} question(s) today (limit: {MAX_NEW_PER_DAY}/day).{Colors.RESET}")
        print(f"{Colors.YELLOW}System design topics require deep focus - consider waiting until tomorrow.{Colors.RESET}")
        confirm = input(f"Add anyway? (y/N): ").strip().lower()
        if confirm != 'y':
            print(f"{Colors.DIM}Cancelled.{Colors.RESET}")
            return

    today = datetime.now()

    # Use smart scheduling to find next available slot
    next_review = schedule_next_review(data, 1)  # First review after 1 day
    next_date = datetime.strptime(next_review, "%Y-%m-%d")
    days_ahead = (next_date.date() - today.date()).days

    # FSRS question structure
    question = {
        "id": str(uuid.uuid4())[:8],
        "name": name,
        "url": url,
        "added_date": today.strftime("%Y-%m-%d"),

        # FSRS fields
        "stability": 0,           # Will be set on first review
        "difficulty": 5.0,        # Default mid-range difficulty
        "state": "new",
        "last_review_date": None,
        "next_review": next_review,
        "reps": 0,

        # Tracking
        "review_count": 0,
        "last_rating": None,
        "history": [],

        # Metadata
        "fsrs_version": 6,
    }

    data["questions"].append(question)
    increment_today_adds(data)
    save_data(data)

    print(f"{Colors.GREEN}Added:{Colors.RESET} {name}")
    if days_ahead == 1:
        print(f"  First review: {Colors.YELLOW}Tomorrow{Colors.RESET}")
    else:
        print(f"  First review: {Colors.BLUE}In {days_ahead} days{Colors.RESET} ({next_review})")

    # Show daily add status
    adds_today = get_today_adds(data)
    if adds_today >= MAX_NEW_PER_DAY:
        print(f"  {Colors.GREEN}Daily limit reached ({adds_today}/{MAX_NEW_PER_DAY}){Colors.RESET}")
    else:
        print(f"  {Colors.DIM}Added: {adds_today}/{MAX_NEW_PER_DAY} today{Colors.RESET}")


def cmd_today(args):
    """Show questions due for review today."""
    data = load_data()
    today = datetime.now().strftime("%Y-%m-%d")

    # Show daily capacity info
    reviews_today = get_today_reviews(data)
    reviews_remaining = MAX_REVIEWS_PER_DAY - reviews_today

    due = [q for q in data["questions"] if q["next_review"] <= today]
    # Sort by most overdue first (priority order)
    due.sort(key=lambda q: q["next_review"])

    if not due:
        print(f"{Colors.GREEN}No reviews due today! You're all caught up.{Colors.RESET}")
        show_add_status(data)
        return

    # Show review capacity
    if reviews_remaining <= 0:
        print(f"{Colors.GREEN}Daily review limit reached ({reviews_today}/{MAX_REVIEWS_PER_DAY}).{Colors.RESET}")
        print(f"{Colors.DIM}Focus on understanding today's topic deeply. More reviews tomorrow.{Colors.RESET}\n")
    else:
        print(f"{Colors.DIM}Reviews remaining today: {reviews_remaining}/{MAX_REVIEWS_PER_DAY}{Colors.RESET}\n")

    priority_count = min(len(due), MAX_DUE_PER_DAY)
    extra_count = len(due) - priority_count

    if extra_count > 0:
        print(f"{Colors.BOLD}=== Due Today ({priority_count} priority + {extra_count} queued) ==={Colors.RESET}\n")
    else:
        print(f"{Colors.BOLD}=== Due Today ({len(due)} question{'s' if len(due) > 1 else ''}) ==={Colors.RESET}\n")

    for i, q in enumerate(due):
        status = format_date(q["next_review"])

        # Calculate retrievability
        stability = q.get("stability", 0)
        last_review = q.get("last_review_date")
        if last_review and stability > 0:
            last_date = datetime.strptime(last_review, "%Y-%m-%d")
            elapsed = (datetime.now() - last_date).days
            r = calculate_retrievability(elapsed, stability)
            r_display = f"R:{r*100:.0f}%"
        else:
            r_display = "New"

        review_info = f"Review #{q['review_count'] + 1} | {r_display}"
        if q.get("last_rating") is not None:
            review_info += f" | Last: {rating_display(q['last_rating'])}"

        # Priority indicator for top MAX_DUE_PER_DAY
        if i < MAX_DUE_PER_DAY:
            priority_marker = f"{Colors.RED}[!]{Colors.RESET} "
        else:
            priority_marker = f"{Colors.DIM}[ ]{Colors.RESET} "

        print(f"  {priority_marker}{Colors.CYAN}{q['name']}{Colors.RESET}")
        print(f"      {status} | {review_info} | Last: {format_last_review(q.get('last_review_date'))}")
        if q["url"]:
            print(f"      {Colors.DIM}{q['url']}{Colors.RESET}")
        print()


def cmd_review(args):
    """Interactive review session using FSRS algorithm."""
    data = load_data()
    today = datetime.now().strftime("%Y-%m-%d")

    # Check daily review limit
    reviews_today = get_today_reviews(data)
    if reviews_today >= MAX_REVIEWS_PER_DAY:
        print(f"{Colors.GREEN}Daily review limit reached ({reviews_today}/{MAX_REVIEWS_PER_DAY}).{Colors.RESET}")
        print(f"{Colors.DIM}System design requires deep focus. Take time to internalize today's concepts.{Colors.RESET}")
        print(f"{Colors.DIM}Tip: Focus on trade-offs, scalability, and failure scenarios.{Colors.RESET}")
        return

    due = [q for q in data["questions"] if q["next_review"] <= today]
    # Sort by most overdue first (priority order)
    due.sort(key=lambda q: q["next_review"])

    if not due:
        print(f"{Colors.GREEN}No reviews due! Use 'systemdesign-srs today' to check schedule.{Colors.RESET}")
        return

    reviews_remaining = MAX_REVIEWS_PER_DAY - reviews_today
    print(f"{Colors.BOLD}=== Review Session (max {reviews_remaining} review{'s' if reviews_remaining > 1 else ''} today) ==={Colors.RESET}\n")

    reviews_done = 0
    for i, q in enumerate(due):
        # Check if we've reached the daily limit
        if reviews_done >= reviews_remaining:
            print(f"\n{Colors.GREEN}Daily review limit reached!{Colors.RESET}")
            print(f"{Colors.DIM}Focus on understanding this topic deeply. More reviews tomorrow.{Colors.RESET}")
            break

        # Calculate current retrievability
        stability = q.get("stability", 0)
        last_review = q.get("last_review_date")
        if last_review and stability > 0:
            last_date = datetime.strptime(last_review, "%Y-%m-%d")
            elapsed = (datetime.now() - last_date).days
            r = calculate_retrievability(elapsed, stability)
            r_display = f"R:{r*100:.0f}%"
        else:
            r_display = "New"

        print(f"{Colors.BOLD}[{i+1}/{len(due)}] {q['name']}{Colors.RESET}")
        if q["url"]:
            print(f"  {Colors.DIM}{q['url']}{Colors.RESET}")
        print(f"  Review #{q['review_count'] + 1} | S:{stability:.1f}d | {r_display} | {format_date(q['next_review'])} | Last: {format_last_review(last_review)}")
        print()

        while True:
            print(f"  How did it go?")
            print(f"    {Colors.MAGENTA}1{Colors.RESET} - Again (forgot key concepts)")
            print(f"    {Colors.RED}2{Colors.RESET} - Hard (struggled with trade-offs)")
            print(f"    {Colors.YELLOW}3{Colors.RESET} - Good (explained with some effort)")
            print(f"    {Colors.GREEN}4{Colors.RESET} - Easy (clear mental model)")
            print(f"    {Colors.DIM}s{Colors.RESET} - Skip for now")
            print(f"    {Colors.DIM}q{Colors.RESET} - Quit review session")

            choice = input(f"\n  Your choice: ").strip().lower()

            if choice == 'q':
                print(f"\n{Colors.YELLOW}Review session ended.{Colors.RESET}")
                save_data(data)
                return
            elif choice == 's':
                print(f"{Colors.DIM}Skipped.{Colors.RESET}\n")
                break
            elif choice in ['1', '2', '3', '4']:
                rating = int(choice)

                # Process review with FSRS algorithm
                new_s, new_d, new_interval, new_state, retrievability = process_review(q, rating, today)

                # Use smart scheduling to find next available slot
                next_date = schedule_next_review(data, new_interval)

                # Update question with FSRS fields
                q["stability"] = new_s
                q["difficulty"] = new_d
                q["state"] = new_state
                q["next_review"] = next_date
                q["last_review_date"] = today
                q["review_count"] += 1
                q["last_rating"] = rating
                q["reps"] = q.get("reps", 0) + 1 if rating > RATING_AGAIN else 0
                q["history"].append({
                    "date": today,
                    "rating": rating,
                    "stability": new_s,
                    "difficulty": new_d,
                    "interval": new_interval,
                    "retrievability": retrievability
                })

                # Increment daily review count
                increment_today_reviews(data)
                reviews_done += 1

                if rating == RATING_AGAIN:
                    print(f"\n  {Colors.MAGENTA}Again!{Colors.RESET} Stability: {Colors.CYAN}{new_s:.1f}d{Colors.RESET} | Next: {next_date}")
                else:
                    actual_interval = (datetime.strptime(next_date, "%Y-%m-%d") - datetime.now()).days + 1
                    print(f"\n  {Colors.GREEN}Recorded!{Colors.RESET} Next review in {Colors.CYAN}{actual_interval} days{Colors.RESET} (S:{new_s:.1f}d)")
                print()
                break
            else:
                print(f"  {Colors.RED}Invalid choice. Enter 1, 2, 3, 4, s, or q.{Colors.RESET}\n")

    save_data(data)
    if reviews_done > 0:
        print(f"{Colors.GREEN}Review session complete! ({reviews_done} review{'s' if reviews_done > 1 else ''} today){Colors.RESET}")


def cmd_list(args):
    """List all questions with their status."""
    data = load_data()

    if not data["questions"]:
        print(f"{Colors.YELLOW}No questions tracked yet. Use 'systemdesign-srs add <name>' to add one.{Colors.RESET}")
        return

    # Sort by next review date
    questions = sorted(data["questions"], key=lambda q: q["next_review"])

    print(f"\n{Colors.BOLD}=== All Questions ({len(questions)}) ==={Colors.RESET}\n")

    for q in questions:
        status = format_date(q["next_review"])

        # Get FSRS fields
        s = q.get("stability", 0)
        d = q.get("difficulty", 5)
        last_review = q.get("last_review_date")

        # Calculate current retrievability
        if last_review and s > 0:
            last_date = datetime.strptime(last_review, "%Y-%m-%d")
            elapsed = (datetime.now() - last_date).days
            r = calculate_retrievability(elapsed, s)
            r_display = f"R:{r*100:.0f}%"
        else:
            r_display = "New"

        print(f"  {Colors.CYAN}{q['name']}{Colors.RESET}")
        print(f"    {status} | S:{s:.1f}d | D:{d:.1f} | {r_display} | Reviews: {q['review_count']} | Last: {format_last_review(last_review)}")
        if q["url"]:
            print(f"    {Colors.DIM}{q['url']}{Colors.RESET}")
        print()


def cmd_stats(args):
    """Show learning statistics."""
    data = load_data()

    if not data["questions"]:
        print(f"{Colors.YELLOW}No questions tracked yet.{Colors.RESET}")
        return

    questions = data["questions"]
    today = datetime.now().strftime("%Y-%m-%d")

    total = len(questions)
    due_today = len([q for q in questions if q["next_review"] <= today])
    total_reviews = sum(q["review_count"] for q in questions)

    # Questions by stability ranges (FSRS maturity)
    learning = len([q for q in questions if q.get("stability", 0) <= 4])
    young = len([q for q in questions if 4 < q.get("stability", 0) <= 21])
    mature = len([q for q in questions if q.get("stability", 0) > 21])

    # Daily stats
    reviews_today = get_today_reviews(data)
    adds_today = get_today_adds(data)

    print(f"\n{Colors.BOLD}=== System Design SRS Statistics (FSRS-6) ==={Colors.RESET}\n")
    print(f"  Total questions:   {Colors.CYAN}{total}{Colors.RESET}")
    print(f"  Due today:         {Colors.YELLOW if due_today else Colors.GREEN}{due_today}{Colors.RESET}")
    print(f"  Total reviews:     {Colors.CYAN}{total_reviews}{Colors.RESET}")
    print()

    print(f"  {Colors.BOLD}Today's Activity:{Colors.RESET}")
    print(f"    Reviews:  {reviews_today}/{MAX_REVIEWS_PER_DAY}")
    print(f"    Added:    {adds_today}/{MAX_NEW_PER_DAY}")
    print()

    # Averages
    if questions:
        avg_s = sum(q.get("stability", 0) for q in questions) / len(questions)
        avg_d = sum(q.get("difficulty", 5) for q in questions) / len(questions)
        print(f"  {Colors.BOLD}Averages:{Colors.RESET}")
        print(f"    Stability:   {Colors.CYAN}{avg_s:.1f}d{Colors.RESET}")
        print(f"    Difficulty:  {Colors.CYAN}{avg_d:.1f}{Colors.RESET}")
        print()

    print(f"  {Colors.BOLD}Question Maturity (by Stability):{Colors.RESET}")
    print(f"    Learning (S<=4d):  {Colors.RED}{learning}{Colors.RESET}")
    print(f"    Young (4<S<=21d):  {Colors.YELLOW}{young}{Colors.RESET}")
    print(f"    Mature (S>21d):    {Colors.GREEN}{mature}{Colors.RESET}")
    print()

    # Upcoming reviews
    upcoming = {}
    for q in questions:
        next_date = q["next_review"]
        delta = (datetime.strptime(next_date, "%Y-%m-%d").date() - datetime.now().date()).days
        if delta <= 7:
            key = max(0, delta)
            upcoming[key] = upcoming.get(key, 0) + 1

    if upcoming:
        print(f"  {Colors.BOLD}Next 7 Days:{Colors.RESET}")
        days = ["Today", "Tomorrow"] + [f"Day {i}" for i in range(2, 8)]
        for i in range(8):
            if i in upcoming:
                bar = "=" * upcoming[i]
                print(f"    {days[i]:10} {Colors.BLUE}{bar}{Colors.RESET} {upcoming[i]}")
    print()


def cmd_delete(args):
    """Delete a question."""
    if not args:
        print(f"{Colors.RED}Usage: systemdesign-srs delete <question-name-or-id>{Colors.RESET}")
        return

    search = args[0].lower()
    data = load_data()

    # Find matching questions
    matches = [q for q in data["questions"]
               if search in q["name"].lower() or search == q["id"]]

    if not matches:
        print(f"{Colors.RED}No question found matching '{args[0]}'{Colors.RESET}")
        return

    if len(matches) > 1:
        print(f"{Colors.YELLOW}Multiple matches found:{Colors.RESET}")
        for q in matches:
            print(f"  [{q['id']}] {q['name']}")
        print(f"\nUse the ID to delete a specific question.")
        return

    question = matches[0]
    confirm = input(f"Delete '{question['name']}'? (y/N): ").strip().lower()

    if confirm == 'y':
        data["questions"] = [q for q in data["questions"] if q["id"] != question["id"]]
        save_data(data)
        print(f"{Colors.GREEN}Deleted: {question['name']}{Colors.RESET}")
    else:
        print(f"{Colors.DIM}Cancelled.{Colors.RESET}")


def cmd_sync(args):
    """Manually sync to git."""
    # Check if we're in a git repo
    result = subprocess.run(
        ["git", "rev-parse", "--is-inside-work-tree"],
        cwd=SCRIPT_DIR,
        capture_output=True,
        text=True
    )
    if result.returncode != 0:
        print(f"{Colors.YELLOW}Not a git repository. Initialize with 'git init' first.{Colors.RESET}")
        return

    # Check if data file exists
    if not DATA_FILE.exists():
        print(f"{Colors.YELLOW}No data file yet. Add some questions first.{Colors.RESET}")
        return

    # Stage and commit
    subprocess.run(["git", "add", DATA_FILE.name], cwd=SCRIPT_DIR, capture_output=True)

    result = subprocess.run(
        ["git", "status", "--porcelain", DATA_FILE.name],
        cwd=SCRIPT_DIR,
        capture_output=True,
        text=True
    )

    if not result.stdout.strip():
        print(f"{Colors.GREEN}Already in sync, no changes to commit.{Colors.RESET}")
    else:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        subprocess.run(
            ["git", "commit", "-m", f"systemdesign-srs: manual sync {timestamp}"],
            cwd=SCRIPT_DIR,
            capture_output=True
        )
        print(f"{Colors.GREEN}Committed changes.{Colors.RESET}")

    # Try to push
    result = subprocess.run(
        ["git", "push"],
        cwd=SCRIPT_DIR,
        capture_output=True,
        text=True
    )
    if result.returncode == 0:
        print(f"{Colors.GREEN}Pushed to remote.{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}Could not push (no remote or offline).{Colors.RESET}")


def cmd_random(args):
    """Select random question(s) weighted by memory weakness."""
    import random

    data = load_data()

    if not data["questions"]:
        print(f"{Colors.YELLOW}No questions yet. Add some with 'systemdesign-srs add'.{Colors.RESET}")
        return

    # Parse arguments
    count = 1
    include_new = False
    start_review = False

    i = 0
    while i < len(args):
        arg = args[i]
        if arg == "--include-new":
            include_new = True
        elif arg == "--review":
            start_review = True
        elif arg.isdigit():
            count = int(arg)
        else:
            print(f"{Colors.RED}Unknown argument: {arg}{Colors.RESET}")
            print(f"Usage: systemdesign-srs random [count] [--review] [--include-new]")
            return
        i += 1

    # Filter eligible questions
    today = datetime.now().date()
    eligible = []

    for q in data["questions"]:
        # Exclude new questions unless flag set
        if not include_new and q.get('state') == 'new':
            continue
        eligible.append(q)

    if not eligible:
        print(f"{Colors.YELLOW}No eligible questions for random selection.{Colors.RESET}")
        if not include_new:
            print(f"{Colors.DIM}Tip: Use --include-new to include unreviewed questions.{Colors.RESET}")
        return

    # Cap count at available
    count = min(count, len(eligible))

    # Calculate weights for all eligible questions
    weights = []
    retrievabilities = []
    for q in eligible:
        weight, r = calculate_question_weight(q, today)
        weights.append(weight)
        retrievabilities.append(r)

    # Weighted random selection
    selected_indices = random.choices(range(len(eligible)), weights=weights, k=count)
    selected_questions = [eligible[i] for i in selected_indices]
    selected_retrievabilities = [retrievabilities[i] for i in selected_indices]

    # Display
    if count == 1:
        question = selected_questions[0]
        r = selected_retrievabilities[0]

        print(f"\n{Colors.BOLD}=== Random Question Selected ==={Colors.RESET}\n")
        print(f"  {Colors.CYAN}{question['name']}{Colors.RESET}")
        print(f"  {Colors.DIM}{question['url']}{Colors.RESET}")
        print()
        print(f"  Selection Reason: {get_selection_reason(question, today, r)}")
        print()

        # Prompt for review if not auto-starting
        if not start_review:
            response = input("Would you like to review this now? (y/N): ").strip().lower()
            if response == 'y':
                start_review = True

        # Review the selected question
        if start_review:
            # Check daily review limit
            reviews_today = get_today_reviews(data)
            if reviews_today >= MAX_REVIEWS_PER_DAY:
                print(f"{Colors.YELLOW}Daily review limit reached ({reviews_today}/{MAX_REVIEWS_PER_DAY}).{Colors.RESET}")
                print(f"{Colors.DIM}System design requires deep focus. Continue tomorrow.{Colors.RESET}")
                return

            today_str = datetime.now().strftime("%Y-%m-%d")

            # Show question info
            stability = question.get("stability", 0)
            print(f"{Colors.BOLD}Reviewing: {question['name']}{Colors.RESET}")
            print(f"  Review #{question['review_count'] + 1} | S:{stability:.1f}d | R:{r*100:.0f}%")
            print()

            while True:
                print(f"  How did it go?")
                print(f"    {Colors.MAGENTA}1{Colors.RESET} - Again (forgot key concepts)")
                print(f"    {Colors.RED}2{Colors.RESET} - Hard (struggled with trade-offs)")
                print(f"    {Colors.YELLOW}3{Colors.RESET} - Good (explained with some effort)")
                print(f"    {Colors.GREEN}4{Colors.RESET} - Easy (clear mental model)")
                print(f"    {Colors.DIM}s{Colors.RESET} - Skip this review")

                choice = input(f"\n  Your choice: ").strip().lower()

                if choice == 's':
                    print(f"{Colors.DIM}Skipped.{Colors.RESET}\n")
                    break
                elif choice in ['1', '2', '3', '4']:
                    rating = int(choice)

                    # Process review with FSRS algorithm
                    new_s, new_d, new_interval, new_state, retrievability = process_review(question, rating, today_str)

                    # Use smart scheduling
                    next_date = schedule_next_review(data, new_interval)

                    # Update question with FSRS fields
                    question["stability"] = new_s
                    question["difficulty"] = new_d
                    question["state"] = new_state
                    question["next_review"] = next_date
                    question["last_review_date"] = today_str
                    question["review_count"] += 1
                    question["last_rating"] = rating
                    question["reps"] = question.get("reps", 0) + 1 if rating > RATING_AGAIN else 0
                    question["history"].append({
                        "date": today_str,
                        "rating": rating,
                        "stability": new_s,
                        "difficulty": new_d,
                        "interval": new_interval,
                        "retrievability": retrievability
                    })

                    # Increment daily review count
                    increment_today_reviews(data)

                    # Save data
                    save_data(data)

                    if rating == RATING_AGAIN:
                        print(f"\n  {Colors.MAGENTA}Again!{Colors.RESET} Stability: {Colors.CYAN}{new_s:.1f}d{Colors.RESET} | Next: {next_date}")
                    else:
                        actual_interval = (datetime.strptime(next_date, "%Y-%m-%d") - datetime.now()).days + 1
                        print(f"\n  {Colors.GREEN}Recorded!{Colors.RESET} Next review in {Colors.CYAN}{actual_interval} days{Colors.RESET} (S:{new_s:.1f}d)")
                    print()
                    break
                else:
                    print(f"  {Colors.RED}Invalid choice. Enter 1, 2, 3, 4, or s.{Colors.RESET}\n")
    else:
        print(f"\n{Colors.BOLD}=== {count} Random Questions Selected ==={Colors.RESET}\n")
        for i, (question, r) in enumerate(zip(selected_questions, selected_retrievabilities), 1):
            reason = get_selection_reason(question, today, r)
            print(f"{i}. {Colors.CYAN}{question['name']}{Colors.RESET}")
            print(f"   {Colors.DIM}{question['url']}{Colors.RESET}")
            print(f"   {reason}")
            print()


def cmd_help(args):
    """Show help message."""
    sync_status = f"{Colors.GREEN}ON{Colors.RESET}" if GIT_SYNC_ENABLED else f"{Colors.RED}OFF{Colors.RESET}"
    print(f"""
{Colors.BOLD}System Design Spaced Repetition System (FSRS-6){Colors.RESET}

{Colors.BOLD}Usage:{Colors.RESET}
  systemdesign-srs <command> [arguments]

{Colors.BOLD}Commands:{Colors.RESET}
  {Colors.CYAN}add{Colors.RESET} <name> [url]   Add a new question to track
  {Colors.CYAN}today{Colors.RESET}              Show questions due for review today
  {Colors.CYAN}review{Colors.RESET}             Start interactive review session
  {Colors.CYAN}list{Colors.RESET}               List all questions with status
  {Colors.CYAN}stats{Colors.RESET}              Show learning statistics
  {Colors.CYAN}delete{Colors.RESET} <name|id>   Delete a question
  {Colors.CYAN}random{Colors.RESET} [count]     Select question(s) by memory weakness
  {Colors.CYAN}sync{Colors.RESET}               Manually sync to git
  {Colors.CYAN}help{Colors.RESET}               Show this help message

{Colors.BOLD}Algorithm (FSRS-6):{Colors.RESET}
  Uses the Free Spaced Repetition Scheduler with:
  - {Colors.CYAN}Stability (S){Colors.RESET}: Memory strength in days (time to drop to 90% recall)
  - {Colors.CYAN}Difficulty (D){Colors.RESET}: Question complexity [1-10]
  - {Colors.CYAN}Retrievability (R){Colors.RESET}: Current recall probability [0-100%]

{Colors.BOLD}Rating Scale:{Colors.RESET}
  {Colors.MAGENTA}1 - Again{Colors.RESET}:  Forgot key concepts (resets learning)
  {Colors.RED}2 - Hard{Colors.RESET}:   Struggled with trade-offs (reduced stability gain)
  {Colors.YELLOW}3 - Good{Colors.RESET}:   Explained with some effort (standard progression)
  {Colors.GREEN}4 - Easy{Colors.RESET}:   Clear mental model (accelerated progression)

{Colors.BOLD}Daily Limits:{Colors.RESET}
  - Max {MAX_NEW_PER_DAY} new question(s) per day (deep focus on each topic)
  - Max {MAX_REVIEWS_PER_DAY} review(s) per day (quality over quantity)
  - Smart scheduling spreads reviews to prevent clustering

{Colors.BOLD}System Design Tips:{Colors.RESET}
  - Focus on trade-offs and scalability decisions
  - Consider failure scenarios and recovery
  - Practice explaining designs out loud
  - Draw diagrams to reinforce mental models

{Colors.BOLD}Git Sync:{Colors.RESET}
  Auto-sync: {sync_status} (edit GIT_SYNC_ENABLED in script to change)
  Data auto-commits and pushes after each change when in a git repo.

{Colors.BOLD}Example Workflow:{Colors.RESET}
  systemdesign-srs add "URL Shortener" "https://example.com/url-shortener"
  systemdesign-srs today
  systemdesign-srs review

{Colors.DIM}Data stored at: {DATA_FILE}{Colors.RESET}
{Colors.DIM}Algorithm: FSRS-6 (https://github.com/open-spaced-repetition){Colors.RESET}
""")


def main():
    """Main entry point."""
    commands = {
        "add": cmd_add,
        "today": cmd_today,
        "review": cmd_review,
        "list": cmd_list,
        "stats": cmd_stats,
        "delete": cmd_delete,
        "random": cmd_random,
        "sync": cmd_sync,
        "help": cmd_help,
    }

    if len(sys.argv) < 2:
        cmd_today([])
        return

    cmd = sys.argv[1].lower()
    args = sys.argv[2:]

    if cmd in commands:
        commands[cmd](args)
    else:
        print(f"{Colors.RED}Unknown command: {cmd}{Colors.RESET}")
        print(f"Use 'systemdesign-srs help' for available commands.")


if __name__ == "__main__":
    main()
